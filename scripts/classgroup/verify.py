"""
Verify the contents of ymcls output directory
"""

import argparse
import json
from pathlib import Path
import sys
import time

from sage.all import *


def main():
    argp = argparse.ArgumentParser()
    argp.add_argument("--all", action="store_true")
    argp.add_argument("DIRECTORY")
    args = argp.parse_args()

    dir = Path(args.DIRECTORY)
    with open(dir / "args.json") as f:
        meta = json.load(f)
    D = int(meta["d"])
    print("Discriminant", D)

    if args.all:
        if (rels := dir / "relations.sieve").is_file():
            verify_rels(rels, D)

    if (rels := dir / "relations.pruned").is_file():
        verify_rels(rels, D)

    if (rels := dir / "relations.removed").is_file():
        verify_removed(rels, D)

    if not (gextra := dir / "group.structure.extra").is_file():
        gextra = None

    if (g := dir / "group.structure").is_file():
        verify_group(g, D, gextra=gextra)


def verify_rels(rels, D):
    match D % 4:
        case 0:
            ONE = BinaryQF([1, 0, -D // 4])
        case 1:
            ONE = BinaryQF([1, 1, (1 - D) // 4])
        case _:
            raise ValueError(f"D must be 0 or 1 modulo 4")

    t0 = time.time()
    with open(rels) as f:
        count = 0
        for line in f:
            line = line.strip()
            facs = [int(p) for p in line.split()]
            pos, neg = [], []
            for f in facs:
                if f > 0:
                    pos.append(f)
                else:
                    neg.append(-f)
                if f > 2 and D % (f * f) == 0:
                    raise ValueError("discriminant is not fundamental")
            # Check
            qpos = ONE
            for l in pos:
                qpos *= qf(l, D)
            qneg = ONE
            for l in neg:
                qneg *= qf(l, D)
            assert qpos.reduced_form() == qneg.reduced_form(), line
            count += 1
        print(f"{rels}: {count} relations verified in {time.time()-t0:.3f}s")


def verify_removed(rels, D):
    match D % 4:
        case 0:
            ONE = BinaryQF([1, 0, -D // 4])
        case 1:
            ONE = BinaryQF([1, 1, (1 - D) // 4])
        case _:
            raise ValueError(f"D must be 0 or 1 modulo 4")

    t0 = time.time()
    with open(rels) as f:
        count = 0
        for line in f:
            line = line.strip()
            p, _, facs_str = line.partition(" = ")
            facs = []
            for le in facs_str.split():
                l, _, e = le.partition("^")
                facs.append((int(l), int(e)))
            p = int(p)
            q1 = qf(p, D)
            q2 = ONE
            for l, e in facs:
                q2 *= qpow(qf(l, D), e, D)
                q2 = q2.reduced_form()
            assert q1.reduced_form() == q2.reduced_form(), line
            count += 1
        print(f"{rels}: {count} relations verified in {time.time()-t0:.3f}s")


def verify_group(g, D, gextra=None):
    with open(g) as f:
        structure = next(f)
        assert structure.startswith("G ")
        invariants = [int(z) for z in structure[2:].strip().split()]

        ZZn = ZZ ** len(invariants)
        G = ZZn / span([_e * ZZn.gen(i) for i, _e in enumerate(invariants)])
        print(G)
        ls = []
        dlogs = []
        gen = []
        gen_done = False
        for line in f:
            words = line.strip().split()
            l = int(words[0])
            dlog = [int(_e) for _e in words[1:]]
            ls.append(l)
            dlogs.append(dlog)
            if not gen_done:
                gen.append(G(dlog))
                if G.submodule(gen) == G:
                    gen_done = True

        print("Generated by", ls[: len(gen)])
        ZZr = ZZ ** len(gen)
        R = ZZr / ZZr.zero_submodule()
        phi = R.hom(gen)
        orders = [g.additive_order() for g in gen]
        # Select one generator with "large" order.
        main_gen_idx = max(zip(orders, range(len(gen))))[1]
        Gg = G / G.submodule([gen[main_gen_idx]])
        partial_orders = [Gg(_g).additive_order() for _g in gen]
        phi1 = R.hom([Gg(_g) for _g in gen])
        phi2 = (ZZ**1 / ZZ**0).hom([gen[main_gen_idx]])

        def coords(g):
            # Return "small" coordinates taking polycyclic relations
            # into account.
            # Write g = x GEN + h
            v = [_x % _o for _x, _o in zip(phi1.lift(g), partial_orders)]
            h = g - sum(_c * _g for _c, _g in zip(v, gen))
            v[main_gen_idx] = phi2.lift(h)[0] % orders[main_gen_idx]
            assert g == sum(_c * _g for _c, _g in zip(v, gen))
            return v

        for l, dlog in zip(ls, dlogs):
            exps = coords(G(dlog))
            q = prod(qpow(qf(_l, D), _e, D).reduced_form() for _l, _e in zip(ls, exps))
            assert q.reduced_form() == qf(l, D)
            factors = "*".join(f"[{_l}]^{_e}" for _l, _e in zip(ls, exps) if _e)
            print(f"OK [{l}] == {factors}")

    if gextra:
        with open(gextra) as f:
            for line in f:
                l, *dlog = line.strip().split()
                l, dlog = int(l), [int(_e) for _e in dlog]
                exps = coords(G(dlog))
                q = prod(
                    qpow(qf(_l, D), _e, D).reduced_form() for _l, _e in zip(ls, exps)
                )
                assert q.reduced_form() == qf(l, D)
                factors = "*".join(f"[{_l}]^{_e}" for _l, _e in zip(ls, exps) if _e)
                print(f"OK [{l}] == {factors}")


@cached_function
def qf(p, D):
    # Convert to binary quadratic form
    assert p == 2 or legendre_symbol(D, p) >= 0
    if D & 1:
        b = ZZ(min(mod(D, 2 * p).sqrt(all=True)))
        c = (ZZ(b) ** 2 - D) // (4 * p)
        assert b * b - 4 * p * c == D
        if p * p < D:
            assert (q := BinaryQF([p, b, c])) == q.reduced_form(), q
        return BinaryQF(p, b, c)
    else:
        if p == 2:
            if D % 8 == 0:
                return BinaryQF(2, 0, -D // 8)
            else:
                return BinaryQF(2, 2, (4 - D) // 8)
        b = ZZ(min(mod(D, 2 * p).sqrt(all=True)))
        c = (ZZ(b) ** 2 - D) // (4 * p)
        assert b * b - 4 * p * c == D
        assert (q := BinaryQF([p, b, c])) == q.reduced_form()
        return BinaryQF(p, b, c)


def qpow(qf, e, D):
    if D % 4 == 1:
        res = BinaryQF([1, 1, (1 - D) // 4])
    else:
        res = BinaryQF([1, 0, -D // 4])
    if e < 0:
        qf = BinaryQF(qf[0], -qf[1], qf[2])
        e = -e
    sq = qf
    while e:
        if e % 2 == 1:
            res = (res * sq).reduced_form()
        sq = (sq * sq).reduced_form()
        e //= 2
    return res


if __name__ == "__main__":
    main()
