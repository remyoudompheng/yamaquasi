// Copyright 2022,2023 Rémy Oudompheng. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//! An implementation of ECM using Edwards curves.
//!
//! Like the rest of Yamaquasi, it only supports numbers under 512 bits.
//!
//! References:
//! <https://gitlab.inria.fr/zimmerma/ecm>
//! <https://eecm.cr.yp.to/index.html>
//!
//! # Curve selection
//!
//! Edwards curve have cheaper group law formulas especially for a=±1
//! making them interesting for ECM.
//!
//! An Edwards curve ax²+y²=1+dx²y² can be converted to (long) Weierstrass
//! form (y²=x³+ a2 x²+ a4) with a2=(a+d)/2 and a4=(a-d)²/16
//!
//! Edwards curves generated by points (3k+5,4k+5) with a=1 are such that
//! d is a square so they have rational torsion Z/2 x Z/4, making them
//! better than average curves with a very simple definition.
//!
//! Special curves from the EECM paper (<https://eecm.cr.yp.to/goodcurves.html>)
//! were previously used.
//!
//! The Suyama-11 family is such that all curves have order divisible by 12 modulo
//! any prime, increasing the probability of the order being smooth. It has a genus 1
//! moduli space, making it possible to generate many curves through point addition.
//!
//! This implementation enumerates curves in deterministic order, using
//! the number to factor as a pseudorandom seed.
//!
//! The elliptic curve group laws are implemented 3 times:
//! - using projective plane coordinates for Edwards curves
//! - using extended coordinates for Edwards curves
//! - using projective coordinates for Weierstrass form
//!
//! # Performance of stage 1
//!
//! Using batch modular inversion, running ECM on a given curve computes
//! a bounded amount of inversions, and scalar multiplication using 1024-bit
//! integers costs 1 doubling and 0.16 point addition per exponent bit in stage 1,
//!
//! # Performance of stage 2
//!
//! This implementation includes the "baby step giant step" optimization
//! for stage 2 as well as the standard FFT continuation giving complexity
//! O(sqrt(B2) (log B2)^x) (see paper "20 Years of ECM" for details).
//!
//! # Extraction of almost equal factors
//!
//! When prime factors are extremely close to each other, they may be caught
//! in the same exponent block, preventing them from being resolved individually.
//! The problem is mitigated by binary searching for the most precise common
//! divisor and using smaller blocks for the few first primes.
//!
//! If a curve is exceptionally unlucky, another one can modify curve orders
//! to avoid sharing factors.
//!
//! Curves with large prescribed torsion like the EECM good curves or Suyama-11 curves
//! make this problem more acute.

use std::cmp::{max, min};
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

use bnum::types::U1024;
use num_integer::Integer;
use rayon::prelude::*;

use crate::arith_gcd;
use crate::arith_montgomery::{gcd_factors, MInt, ZmodN};
use crate::arith_poly::Poly;
use crate::fbase;
use crate::params::stage2_params;
use crate::{Preferences, Uint, UnexpectedFactor, Verbosity};

/// Run ECM with automatically selected small parameters.
///
/// The goal of this function is not to completely factor numbers, but
/// to detect cases where a number has a relatively small prime factor
/// (about size(n) / 5)
pub fn ecm_auto(
    n: Uint,
    prefs: &Preferences,
    tpool: Option<&rayon::ThreadPool>,
) -> Option<(Uint, Uint)> {
    // The CPU budget here is only a few seconds (at most 1% of SIQS time).
    // So we intentionally use small parameters hoping to be very lucky.
    // This means that the parameters should be tuned to find factors
    // smaller than about n^1/4.
    match n.bits() {
        // Skip: Pollard's rho algorithm is faster.
        0..=64 => None,
        // Target 32-bit factors
        65..=160 => ecm(n, 8, 200, 7.7e3, prefs, tpool),
        // Target 40 bit factors (budget 10-20ms)
        161..=190 => ecm(n, 20, 600, 20e3, prefs, tpool),
        // Target 48 bit factors (budget <100ms)
        191..=220 => ecm(n, 25, 2000, 80e3, prefs, tpool),
        // Target 52 bit factors (budget 0.1-0.5s)
        221..=250 => ecm(n, 40, 2500, 126e3, prefs, tpool),
        // Target 64 bit factors (budget 2-3s)
        251..=280 => ecm(n, 100, 10000, 554e3, prefs, tpool),
        // Target 72 bit factors (budget 5-10s)
        281..=310 => ecm(n, 150, 25_000, 1.37e6, prefs, tpool),
        // Target 80 bit factors (budget 20-30s)
        311..=340 => ecm(n, 100, 100_000, 19e6, prefs, tpool),
        // Target 92 bit factors (budget 1mn)
        341..=370 => ecm(n, 250, 200_000, 38e6, prefs, tpool),
        // For very large numbers, we don't expect quadratic sieve to complete
        // in reasonable time, so all hope is on ECM.
        371..=450 => {
            // Target 108-bit factors, budget is more than 10 minutes
            ecm(n, 300, 1_500_000, 2.6e9, prefs, tpool)
        }
        451.. => {
            // Try 108-bits or 128 bit factors(several seconds per curve)
            ecm(n, 300, 1_500_000, 2.6e9, prefs, tpool)
                .or_else(|| ecm(n, 1000, 5_000_000, 32e9, prefs, tpool))
        }
    }
}

/// Factor number using purely ECM. This may never end, or fail.
pub fn ecm_only(
    n: Uint,
    prefs: &Preferences,
    tpool: Option<&rayon::ThreadPool>,
) -> Option<(Uint, Uint)> {
    // B1 values should be such that step 1 takes about as much time as step 2.
    // D values are only such that phi(D) is a bit less than a power of 2.

    // Only try as many curves as required by a reference factor size.
    // There is no use running too many curves for given B1/B2 choices.

    // Target 32 bit primes
    ecm(n, 10, 200, 7.7e3, prefs, tpool)
        // Or 48-bit primes (20x longer)
        .or_else(|| ecm(n, 30, 2000, 81e3, prefs, tpool))
        // Or 64-bit primes (15x longer)
        .or_else(|| ecm(n, 100, 10_000, 554e3, prefs, tpool))
        // Or 80-bit primes (10-15x longer)
        .or_else(|| ecm(n, 100, 100_000, 19e6, prefs, tpool))
        // Or 96-bit primes (8-10x longer)
        .or_else(|| ecm(n, 200, 300_000, 156e6, prefs, tpool))
        // Or 120-bit primes (15-20x longer)
        .or_else(|| ecm(n, 600, 3_000_000, 10e9, prefs, tpool))
        // Or 144-bit primes (10-15x longer)
        .or_else(|| ecm(n, 2000, 15_000_000, 136e9, prefs, tpool))
        // Or 168-bit primes (10x longer, >1 minute per curve)
        .or_else(|| ecm(n, 10000, 60_000_000, 1500e9, prefs, tpool))
        // Or 192-bit primes/60 digits (10x longer, >5 minutes per curve)
        .or_else(|| ecm(n, 15000, 350_000_000, 49e12, prefs, tpool))
}

// Run ECM for a given number of curves and bounds B1, B2.
pub fn ecm(
    n: Uint,
    curves: usize,
    b1: usize,
    b2: f64,
    prefs: &Preferences,
    tpool: Option<&rayon::ThreadPool>,
) -> Option<(Uint, Uint)> {
    let (b2, _, _) = stage2_params(b2);
    if prefs.verbose(Verbosity::Info) {
        eprintln!("Attempting ECM with {curves} curves B1={b1} B2={b2:e}",);
    }
    let start = std::time::Instant::now();
    let zn = ZmodN::new(n);
    let sb = SmoothBase::new(b1, true);
    // Keep track of how many curves were examined.
    let iters = AtomicUsize::new(0);
    let done = AtomicBool::new(false);

    // Generate seeds using a simple 16-bit or 32-bit LCG.
    // We never need more than 10k seeds.
    // TODO: optionally use non-deterministic selection.
    let s0 = n.digits()[0];
    let m0 = 2 * curves as u64 + 1;
    let mut seeds = vec![];
    let mut seed = s0;
    if curves >= 100 || n.bits() >= 32 {
        // Always an odd number. The multiplicative order of m0 is always large.
        for _ in 0..curves {
            seed = seed.wrapping_mul(m0);
            seeds.push(max(2, seed as u32));
        }
    } else {
        for _ in 0..curves {
            seed = seed.wrapping_mul(m0);
            seeds.push(max(2, seed as u16 as u32));
        }
    }
    assert!(seeds.len() == curves);

    // Choose curves from the Suyama-11 family.
    // They have torsion Z/12Z modulo every prime.
    //
    // Parameters of the Suyama curves involve elliptic curve
    // arithmetic and will be computed on the fly, which requires
    // a modular inversion. We expect that this cost is negligible
    // compared to actual ECM main computation.

    // In case of failure (especially if the generator of the family
    // has low order modulo all factors of n) fall back to an Edwards
    // curve with torsion Z/2 x Z/4. There is a very easy infinite supply
    // of such curves because (3k+5)² + (4k+5)² = 1 + (5k+7)².
    //
    // They are less effective than Suyama-11 curves but should not
    // simultaneously fail.

    let suyama = Suyama11::new(&zn).unwrap();
    let do_curve = |seed: u32| {
        assert!(seed >= 2);
        if done.load(Ordering::Relaxed) || prefs.abort() {
            return None;
        }
        let iter = iters.fetch_add(1, Ordering::SeqCst) + 1;
        let curve = suyama
            .element(seed)
            .and_then(|p| suyama.params_point(&p))
            .and_then(|g| Curve::twisted_from_point(zn.clone(), g));
        let fallback = {
            let seed = seed as u64 % (1 << 24);
            (3 * seed + 5, 4 * seed + 5)
        };
        let curve = match curve {
            Err(UnexpectedLargeFactor(p)) if p == n => {
                // This is very unlikely unless n is very small.
                if prefs.verbose(Verbosity::Debug) {
                    eprintln!("Suyama curve failure seed={seed}")
                }
                Curve::from_point(zn.clone(), fallback.0, fallback.1)
                    .map_err(|err| UnexpectedLargeFactor(err.0.into()))
            }
            _ => curve,
        };
        let c = match curve {
            Ok(c) => c,
            Err(UnexpectedLargeFactor(p)) => {
                if p == n {
                    // This should be truly exceptional.
                    if prefs.verbose(Verbosity::Debug) {
                        eprintln!("curve failure seed={seed}")
                    }
                    return None;
                }
                if prefs.verbose(Verbosity::Info) {
                    eprintln!("Unexpected factor {p}");
                }
                done.store(true, Ordering::Relaxed);
                return Some((p, n / p));
            }
        };
        if prefs.verbose(Verbosity::Verbose) {
            if c.twisted {
                eprintln!("Trying Suyama-11 curve with parameter [{seed}]G");
            } else {
                let (gx, gy) = fallback;
                eprintln!("Trying Edwards curve with generator G=({gx},{gy})");
            }
        }
        if let res @ Some((p, _)) = ecm_curve(&sb, &zn, &c, b2, prefs.verbosity) {
            if prefs.verbose(Verbosity::Info) {
                let (a, mut d) = c.a_d();
                let elapsed = start.elapsed().as_secs_f64();
                d = d % p;
                eprintln!("ECM found factor {p} at curve {iter}/{curves} (Edwards a={a} d={d}) elapsed={elapsed:.3}s");
            }
            done.store(true, Ordering::Relaxed);
            return res;
        }
        None
    };
    if let Some(pool) = tpool {
        let results: Vec<Option<_>> =
            pool.install(|| seeds.par_iter().map(|&k| do_curve(k)).collect());
        for r in results {
            if r.is_some() {
                return r;
            }
        }
    } else {
        for s in seeds {
            if let Some(res) = do_curve(s) {
                return Some(res);
            }
        }
    }
    if prefs.verbose(Verbosity::Info) {
        eprintln!("ECM failure after {:.3}s", start.elapsed().as_secs_f64());
    }
    None
}

fn ecm_curve(
    sb: &SmoothBase,
    zn: &ZmodN,
    c: &Curve,
    b2: f64,
    verbosity: Verbosity,
) -> Option<(Uint, Uint)> {
    let n = &zn.n;
    let (_, d1, d2) = stage2_params(b2);
    // ECM stage 1
    let start1 = std::time::Instant::now();
    let mut g = c.gen().clone();
    const GCD_INTERVAL: usize = 1000;
    let mut gxs = Vec::with_capacity(GCD_INTERVAL);
    let mut last_gx = zn.one();
    for block in sb.factors.chunks(GCD_INTERVAL) {
        // Once g.0 is divisible by p, it will be for the rest of the loop.
        gxs.clear();
        gxs.push(last_gx);
        for &f in block {
            g = c.scalar64_chainmul(f, &g);
            gxs.push(g.0);
        }
        last_gx = g.0;
        if let Some(d) = check_gcd_factor(n, &gxs) {
            return Some((d, n / d));
        }
    }
    gxs.clear();
    gxs.push(g.0);
    for f in sb.larges.iter() {
        g = c.scalar1024_chainmul(f, &g);
        gxs.push(g.0);
    }
    if let Some(d) = check_gcd_factor(n, &gxs) {
        return Some((d, n / d));
    }
    drop(gxs);
    assert!(
        c.is_valid(&g),
        "invalid point G=[{}:{}:{}] for d={} mod {}",
        c.zn.to_int(g.0),
        c.zn.to_int(g.1),
        c.zn.to_int(g.2),
        c.zn.to_int(c.d),
        c.zn.n
    );
    let elapsed1 = start1.elapsed();

    // ECM stage 2
    // The order of G (hopefully) no longer has small prime factors.
    // Look for a "large" prime order. Instead of computing [l]G
    // for all primes l, use the baby step giant step method:
    //
    // [l]G = 0 translates to [ad+b]G = 0 or [ad]G = [-b]G
    // whre d² <= B2, a <= d, b in [-d/2, d/2] is coprime to d.
    //
    // Since the opposite of (x,y) is (-x,y) this means that
    // [ad]G and [abs(b)]G have the same coordinate y.
    //
    // After stage 1 we know that [ad]G and [abs(b)]G are never zero.
    let start2 = std::time::Instant::now();

    // Prepare values of abs(b): there are phi(d1)/2 < d1/4 such values.
    let mut bs = Vec::with_capacity(d1 as usize / 4);
    for b in 1..d1 / 2 {
        if Integer::gcd(&b, &d1) == 1 {
            bs.push(b);
        }
    }
    let g2 = c.double(&g);
    let g4 = c.double(&g2);
    let mut gaps = vec![c.to_extended(&g2), c.to_extended(&g4)];
    // Baby/giant steps in a single vector.
    let mut steps = Vec::with_capacity(d1 as usize / 4 + d2 as usize);
    // Compute the baby steps
    let mut bg = c.to_extended(&g);
    let mut bexp = 1;
    assert_eq!(bs[0], 1);
    steps.push(g.clone());
    let mut n_bsteps = 1 as usize;
    for &b in &bs[1..] {
        let gap = b - bexp;
        while gaps.len() < gap as usize / 2 {
            let gap2 = c.addext(&gaps[0], &gaps[gaps.len() - 1]);
            gaps.push(gap2);
        }
        bg = c.addext(&bg, &gaps[gap as usize / 2 - 1]);
        steps.push(bg.to_proj());
        n_bsteps += 1;
        bexp = b;
    }
    // Compute the giant steps
    // WARNING: extended coordinate addition must not be used
    // to compute the first step.
    let dg = c.scalar64_chainmul(d1, &g);
    let dg2 = c.double(&dg);
    let dgext = c.to_extended(&dg);
    let mut gg = c.to_extended(&dg2);
    steps.push(dg);
    steps.push(dg2);
    for _ in 2..d2 {
        gg = c.addext(&gg, &dgext);
        steps.push(gg.to_proj());
    }
    // Normalize Y coordinates, 4 multiplications per point:
    // replace y[i] by y[i]/z[i] * product(z[j])
    // Compute u[i] = p[0] * ... * p[i-1]
    // Compute v[i] = p[i+1] * ... * p[d]
    // Then product(z[j]) / z[i] = u[i] * v[i]
    {
        let l = steps.len();
        let mut u = steps[0].2;
        for i in 1..l {
            steps[i].1 = zn.mul(&steps[i].1, &u);
            u = zn.mul(&u, &steps[i].2);
        }
        u = steps[l - 1].2;
        for i in 2..=l {
            steps[l - i].1 = zn.mul(&steps[l - i].1, &u);
            u = zn.mul(&u, &steps[l - i].2);
        }
    }

    let stage2_roots_time = start2.elapsed().as_secs_f64();

    let bsteps = &steps[..n_bsteps];
    let gsteps = &steps[n_bsteps..];
    let mut result = None;
    if d1 < 4000 {
        // Compute O(d*phi(d)) products
        let mut buffer = zn.one();
        let mut prods = Vec::with_capacity(gsteps.len());
        prods.push(buffer);
        for pg in gsteps {
            // Compute the gcd after each row for finer granularity.
            for pb in bsteps {
                // y(G) - y(B)
                let delta_y = zn.sub(&pg.1, &pb.1);
                buffer = zn.mul(&buffer, &delta_y);
            }
            prods.push(buffer);
        }
        if let Some(d) = check_gcd_factor(n, &prods) {
            result = Some((d, n / d));
        }
    } else {
        // Usually D > 4 phi(D) (phi(2*3*5*7) < N/4)
        // And there are only phi(D)/2 baby steps
        //
        // If we split gsteps into blocks, each of them multieval'ed on bsteps.
        // the complexity will be O(gsteps/bsteps * bsteps log(bsteps)^alpha)
        //
        // However, the multipoint evaluation is ~10x the complexity of
        // a polynomial product.
        // It is more efficient to compute the (large) polynomial
        // PG=Product(X - pgs[i]) and reduce it modulo PB=Product(X - pbs[j])
        // and compute a single remainder tree.
        // (See "20 years of ECM" article)
        //
        // Efficiency is maximal if #bsteps is very close to a power of 2
        // and if PG/PB can be computed efficiently.
        let pbs: Vec<MInt> = bsteps.iter().map(|p| p.1).collect();
        let pgs: Vec<MInt> = gsteps.iter().map(|p| p.1).collect();
        let mut vals = Poly::roots_eval(zn, &pgs, &pbs);
        let mut prod = zn.one();
        // Replace array by cumulative products.
        for i in 0..vals.len() {
            let v = vals[i];
            vals[i] = prod;
            prod = zn.mul(&prod, &v);
        }
        vals.push(prod);
        if let Some(d) = check_gcd_factor(n, &vals) {
            result = Some((d, n / d));
        }
    }
    if verbosity >= Verbosity::Verbose {
        let stage1 = elapsed1.as_secs_f64();
        let stage2 = start2.elapsed().as_secs_f64();
        let roots_pct = 100. * stage2_roots_time / stage2;
        if stage2 < 0.01 {
            eprintln!("ECM stage1={stage1:.6}s stage2={stage2:.6}s (stage2 roots {roots_pct:.1}%)");
        } else {
            eprintln!("ECM stage1={stage1:.3}s stage2={stage2:.3}s (stage2 roots {roots_pct:.1}%)");
        }
    }
    result
}

/// Extract a single factor using GCD.
fn check_gcd_factor(n: &Uint, values: &[MInt]) -> Option<Uint> {
    // FIXME: we should return all factors. We just
    // return the largest one.
    let fs = gcd_factors(n, &values[..]).0;
    fs.iter().filter(|f| f != &n).max().copied()
}

/// An exponent base for ECM.
pub struct SmoothBase {
    /// Chunks of primes multiplied into u64 integers.
    pub(crate) factors: Box<[u64]>,
    /// Large chunks of primes (1024 bits)
    larges: Box<[Uint]>,
}

impl SmoothBase {
    pub fn new(b1: usize, use_large: bool) -> Self {
        const LARGE_THRESHOLD: u64 = 4096;
        let primes = if b1 < 65_536 {
            fbase::primes(b1 as u32 / 2)
        } else {
            let mut s = fbase::PrimeSieve::new();
            let mut primes = vec![];
            loop {
                let b = s.next();
                primes.extend_from_slice(b);
                if b[b.len() - 1] > b1 as u32 {
                    break;
                }
            }
            primes
        };
        let mut factors = vec![];
        let mut factors_lg = vec![];
        let mut buffer = 1_u64;
        let mut buffer_lg = U1024::ONE;
        for p in primes {
            // Small primes are raised to some power (until B1).
            if p >= b1 as u32 {
                break;
            }
            let p = p as u64;
            let mut pow = p;
            while pow * p < b1 as u64 {
                pow *= p;
            }
            // Curve order has extra 2 and 3 factors.
            if p == 2 {
                pow *= 16;
            }
            if p == 3 {
                pow *= 3;
            }
            // Avoid too many primes in exponent buffer.
            // Small primes must make smaller blocks.
            if p < 256 && buffer > 1 << 32 {
                factors.push(buffer);
                buffer = 1;
            }
            if 1 << buffer.leading_zeros() <= pow {
                if p < LARGE_THRESHOLD || !use_large {
                    factors.push(buffer);
                    buffer = 1;
                } else {
                    buffer_lg *= Uint::from_digit(buffer);
                    buffer = 1;
                }
            }
            if buffer_lg.bits() > 1024 - 64 {
                factors_lg.push(buffer_lg);
                buffer_lg = Uint::ONE;
            }
            buffer *= pow;
        }
        if buffer > 1 {
            if (b1 as u64) < LARGE_THRESHOLD || !use_large {
                factors.push(buffer);
            } else {
                buffer_lg *= Uint::from_digit(buffer);
            }
        }
        if buffer_lg > Uint::ONE {
            factors_lg.push(buffer_lg)
        }
        SmoothBase {
            factors: factors.into_boxed_slice(),
            larges: factors_lg.into_boxed_slice(),
        }
    }
}

/// An elliptic curve in (twisted) Edwards form ax²+y² = 1 + dx²y²
/// where a = ±1
pub struct Curve {
    /// The base ring
    zn: ZmodN,
    /// Whether the curve has a=-1
    twisted: bool,
    d: MInt,
    // Coordinates of a "non-torsion" base point.
    g: Point,
}

/// A point in the projective plane using homogeneous coordinates.
#[derive(Clone, Debug)]
pub struct Point(MInt, MInt, MInt);

impl Point {
    pub(crate) fn xyz(&self) -> (MInt, MInt, MInt) {
        (self.0, self.1, self.2)
    }
}

/// An Edwards curve point in extended coordinates (x,y,z,t)
/// located in the quadric xy=zt.
///
/// The equation of the Edwards curve in these coordinates is:
/// a x^2 + y^2 = z^2 + d t^2
///
/// Addition in this representation costs 8 multiplications
/// instead of 12, making it ideal for stage 2.
#[derive(Clone, Debug)]
pub struct ExtPoint(MInt, MInt, MInt, MInt);

impl ExtPoint {
    fn to_proj(&self) -> Point {
        Point(self.0, self.1, self.2)
    }
}

#[derive(Debug)]
#[doc(hidden)]
pub struct UnexpectedLargeFactor(pub(crate) Uint);

impl UnexpectedLargeFactor {
    fn new(zn: &ZmodN, x: &MInt) -> Self {
        let d = Integer::gcd(&zn.n, &Uint::from(*x));
        assert!(d != Uint::ONE);
        Self(d)
    }
}

fn zn_divide(zn: &ZmodN, a: &MInt, b: &MInt) -> Result<MInt, UnexpectedLargeFactor> {
    match zn.inv(*b) {
        Some(binv) => Ok(zn.mul(a, &binv)),
        None => Err(UnexpectedLargeFactor::new(zn, b)),
    }
}

impl Curve {
    fn fraction_modn(zn: &ZmodN, a: i64, b: i64) -> Result<MInt, UnexpectedFactor> {
        fn to_uint(n: Uint, x: i64) -> Uint {
            if x >= 0 {
                Uint::from(x as u64) % n
            } else {
                n - Uint::from((-x) as u64) % n
            }
        }
        let binv = match arith_gcd::inv_mod(&to_uint(zn.n, b), &zn.n) {
            Ok(inv) => inv,
            Err(d) => return Err(UnexpectedFactor(d.digits()[0])),
        };
        Ok(zn.mul(zn.from_int(to_uint(zn.n, a)), zn.from_int(binv)))
    }

    // Construct the unique curve through a point with nonzero
    // coordinates.
    pub fn from_point(zn: ZmodN, x: u64, y: u64) -> Result<Curve, UnexpectedFactor> {
        assert!(x < 1 << 31 && y < 1 << 31);
        // Compute d = (x²+y²-1) / x²y²
        let gx = zn.from_int(Uint::from(x) % zn.n);
        let gy = zn.from_int(Uint::from(y) % zn.n);
        // gx*gx + gy*gy - 1
        let dn = Self::fraction_modn(&zn, (x * x + y * y - 1) as i64, 1)?;
        let dd = Self::fraction_modn(&zn, 1, (x * y) as i64)?;
        let d = zn.mul(zn.mul(dn, dd), dd);
        let g = Point(gx, gy, zn.one());
        Ok(Curve {
            zn,
            twisted: false,
            d,
            g,
        })
    }

    pub fn twisted_from_point(zn: ZmodN, g: Point) -> Result<Curve, UnexpectedLargeFactor> {
        // (-x²+y²)z² = z^4 + dx²y²
        // d = (y^2 - x^2 - z^2)z^2 / x^2 y^2
        let x2 = zn.mul(&g.0, &g.0);
        let y2 = zn.mul(&g.1, &g.1);
        let z2 = zn.mul(&g.2, &g.2);
        let dn = zn.mul(&z2, &zn.sub(&zn.sub(&y2, &x2), &z2));
        let dd = zn.mul(&x2, &y2);
        let d = zn_divide(&zn, &dn, &dd)?;
        Ok(Curve {
            zn,
            twisted: true,
            d,
            g,
        })
    }

    pub fn gen(&self) -> &Point {
        &self.g
    }

    pub fn n(&self) -> &Uint {
        &self.zn.n
    }

    pub fn a_d(&self) -> (i64, Uint) {
        (if self.twisted { -1 } else { 1 }, self.zn.to_int(self.d))
    }

    // Addition formula following add-2007-bl (a=1) and add-2008-bbjlp (a=-1)
    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#addition-add-2007-bl
    //
    // Both formulas are strongly unified and work even for P=Q.
    fn add(&self, p: &Point, q: &Point) -> Point {
        // 12 multiplications are required.
        let zn = &self.zn;
        // Handle z
        let a = zn.mul(&p.2, &q.2);
        let b = zn.mul(&a, &a);
        // Karatsuba-like product
        let c = zn.mul(&p.0, &q.0);
        let d = zn.mul(&p.1, &q.1);
        let cd = zn.mul(&zn.add(&p.0, &p.1), &zn.add(&q.0, &q.1));
        let c_plus_d = zn.add(&c, &d);
        let cross = zn.sub(&cd, &c_plus_d);

        let e = zn.mul(&self.d, &zn.mul(&c, &d));
        let f = zn.sub(&b, &e);
        let g = zn.add(&b, &e);

        // See formula add-2008-bbjlp for the a=-1 case.
        let x = zn.mul(&zn.mul(&a, &f), &cross);
        let y = zn.mul(
            zn.mul(&a, &g),
            if self.twisted {
                c_plus_d
            } else {
                zn.sub(&d, &c)
            },
        );
        let z = zn.mul(&f, &g);
        Point(x, y, z)
    }

    /// Addition formula for extended coordinates on twisted Edwards curves.
    ///
    /// For a=-1, it requires 8 modular multiplications
    /// <https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4>
    /// For a=1, it requires 9 modular multiplications
    /// <https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd-2>
    ///
    /// Warning: these formulas are not "strongly unified" and will return
    /// zero coordinates if P=Q. We expect this case to only happen by
    /// accident (finding a factor during stage 2 steps) and not
    /// by design (doubling a point).
    ///
    /// If the caller requires projective coordinates as output, 1 multiplication can be removed.
    fn addext(&self, p: &ExtPoint, q: &ExtPoint) -> ExtPoint {
        self._addext(p, q, false)
    }

    fn addextproj(&self, p: &ExtPoint, q: &ExtPoint) -> Point {
        self._addext(p, q, true).to_proj()
    }

    fn _addext(&self, p: &ExtPoint, q: &ExtPoint, proj: bool) -> ExtPoint {
        let zn = &self.zn;
        let (a, b, c, d) = if self.twisted {
            // Formula add-2008-hwcd-4 in Explicit Formula Database
            // (yP - xP)(yQ + xQ), (yP + xP)(yQ - xQ)
            let a = zn.mul(&zn.sub(&p.1, &p.0), &zn.add(q.1, q.0));
            let b = zn.mul(&zn.add(&p.1, &p.0), &zn.sub(q.1, q.0));
            // 2 zP tQ, 2 zQ tP
            let c = zn.mul(&p.2, &q.3);
            let c = zn.add(&c, &c);
            let d = zn.mul(&p.3, &q.2);
            let d = zn.add(&d, &d);
            (a, b, c, d)
        } else {
            // Formula add-2008-hwcd-2 in Explicit Formula Database
            (
                zn.mul(&p.0, &q.0),
                zn.mul(&p.1, &q.1),
                zn.mul(&p.2, &q.3),
                zn.mul(&p.3, &q.2),
            )
        };
        let e = zn.add(&d, &c);
        let f = if self.twisted {
            zn.sub(&b, &a)
        } else {
            // xP yQ - xQ yP = (xP-yP)*(xQ+yQ) +yPyQ -xPxQ
            zn.add(
                &zn.mul(&zn.sub(p.0, p.1), &zn.add(q.0, q.1)),
                &zn.sub(&b, &a),
            )
        };
        let g = zn.add(&b, &a);
        let h = zn.sub(&d, &c);
        // xy(P+Q) = zt(P+Q) = efgh
        ExtPoint(
            zn.mul(&e, &f),
            zn.mul(&g, &h),
            zn.mul(&f, &g),
            // Skip multiplication if unneeded.
            if proj { zn.zero() } else { zn.mul(&e, &h) },
        )
    }

    /// Doubling formula for extended coordinates on Edwards curves with a=±1
    ///
    /// Due to invariance properties, this formula can be expressed without the last coordinates,
    /// so it can take projective coordinates as input, costing 8 multiplications.
    ///
    /// The formula is dbl-2008-hwcd
    /// <https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd>
    fn dblext(&self, p: &Point) -> ExtPoint {
        let zn = &self.zn;
        let x_y = zn.add(&p.0, &p.1);
        let x_y2 = zn.mul(&x_y, &x_y);
        let a = zn.mul(&p.0, &p.0);
        let b = zn.mul(&p.1, &p.1);
        let c = zn.mul(&p.2, &p.2);
        let c = zn.add(&c, &c);
        let e = zn.sub(&zn.sub(&x_y2, &a), &b);
        let (f, g, h) = if self.twisted {
            // D=-A, G=B-A, H=-B-A, F=G-C
            let g = zn.sub(&b, &a);
            (zn.sub(&g, &c), g, zn.sub(zn.zero(), zn.add(&a, &b)))
        } else {
            // D=A, G=B+A, H=A-B, F=G-C
            let g = zn.add(&a, &b);
            (zn.sub(&g, &c), g, zn.sub(&a, &b))
        };
        ExtPoint(
            zn.mul(&e, &f),
            zn.mul(&g, &h),
            zn.mul(&f, &g),
            zn.mul(&e, &h),
        )
    }

    #[allow(dead_code)]
    fn sub(&self, p: &Point, q: &Point) -> Point {
        let q = Point(self.zn.sub(&self.zn.zero(), &q.0), q.1, q.2);
        self.add(p, &q)
    }

    fn subextproj(&self, p: &ExtPoint, q: &ExtPoint) -> Point {
        let q = ExtPoint(
            self.zn.sub(&self.zn.zero(), &q.0),
            q.1,
            q.2,
            self.zn.sub(&self.zn.zero(), &q.3),
        );
        self.addextproj(p, &q)
    }

    // Doubling formula following dbl-2007-bl
    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#doubling-dbl-2007-bl
    fn double(&self, p: &Point) -> Point {
        // 7 multiplications are required.
        let zn = &self.zn;
        // Handle z
        let x_plus_y = zn.add(&p.0, &p.1);
        let b = zn.mul(&x_plus_y, &x_plus_y);
        let c = zn.mul(&p.0, &p.0);
        let d = zn.mul(&p.1, &p.1);
        if self.twisted {
            // Formula dbl-2008-bbjlp
            let c_plus_d = zn.add(&c, &d);
            let f = zn.sub(&d, &c);
            let h = zn.mul(&p.2, &p.2);
            let j = zn.sub(&zn.sub(&f, &h), &h);
            let x = zn.mul(&zn.sub(&b, &c_plus_d), &j);
            let y = zn.mul(&f, &zn.sub(&zn.zero(), &c_plus_d));
            let z = zn.mul(&f, &j);
            Point(x, y, z)
        } else {
            let e = zn.add(&c, &d);
            let h = zn.mul(&p.2, &p.2);
            let j = zn.sub(&zn.sub(&e, &h), &h);
            // Final result
            let x = zn.mul(&zn.sub(&b, &e), &j);
            let y = zn.mul(&e, &zn.sub(&c, &d));
            let z = zn.mul(&e, &j);
            Point(x, y, z)
        }
    }

    /// Naïve double-and-add scalar multiplication.
    /// It must not be used in ordinary code, and exists only for testing purposes.
    pub fn scalar64_mul_dbladd(&self, k: u64, p: &Point) -> Point {
        let zn = &self.zn;
        let mut res = Point(zn.zero(), zn.one(), zn.one());
        let mut sq: Point = p.clone();
        let mut k = k;
        while k > 0 {
            if k & 1 == 1 {
                res = self.add(&res, &sq);
            }
            sq = self.double(&sq);
            k >>= 1;
        }
        res
    }

    pub fn scalar64_chainmul(&self, k: u64, p: &Point) -> Point {
        if k == 0 {
            let zn = &self.zn;
            return Point(zn.zero(), zn.one(), zn.one());
        }
        // Compute an addition chain for k as in
        // https://eprint.iacr.org/2007/455.pdf
        // We find that m=7 is optimal for 64-bit blocks (~14 adds instead of 28 for ~56-bit blocks)
        // For 32-bit blocks, the optimal value is m=5 (7 adds instead of 12 for ~22-bit blocks)
        //
        // Doubling in projective coordinates costs 7 multiplications.
        // Doubling and add in extended coordinates costs 15 multiplications (16 if a=1).
        // See also https://eprint.iacr.org/2008/522, section 4.3
        let pext = self.to_extended(p);
        let p2 = self.dblext(p);
        let p3 = self.addext(&pext, &p2);
        let p5 = self.addext(&p3, &p2);
        let p7 = self.addext(&p5, &p2);
        let gaps = [&pext, &p3, &p5, &p7];
        // Encode the chain as:
        // 2l (doubling l times)
        // ±k (X -> 2X ± kP where k is odd)
        let mut c = [0_i8; 32];
        let l = Self::make_addition_chain(&mut c, k);
        // Get initial element (chain[l-1] = 1 or 3 or 5 or 7)
        let mut q = gaps[c[l - 1] as usize / 2].to_proj();
        for idx in 1..l {
            let op = c[l - 1 - idx];
            if op % 2 == 0 {
                for _ in 0..op / 2 {
                    q = self.double(&q);
                }
            } else {
                let q2 = self.dblext(&q);
                if op > 0 {
                    q = self.addextproj(&q2, gaps[op as usize / 2]);
                } else {
                    q = self.subextproj(&q2, gaps[(-op) as usize / 2]);
                }
            }
        }
        q
    }

    pub(crate) fn make_addition_chain(chain: &mut [i8; 32], k: u64) -> usize {
        // Build an addition chain for a 64-bit multiplier
        // as a reversed list of opcodes:
        // - an odd opcode x (|x| <= 7) means: P -> 2P + xG
        // The combined double-add is because it can be computed
        // with 16 MULs instead of 19 MULs.
        // - an even opcode 2y means: P -> 2^y P
        //
        // For any integer, 2 opcodes can remove 4 bits, so the chain length
        // is never more than 32.
        if k == 0 {
            chain[0] = 0;
            return 1;
        }
        let mut l = 0;
        let mut kk = k;
        loop {
            if kk % 2 == 0 {
                let tz = kk.trailing_zeros();
                chain[l] = 2 * tz as i8;
                kk >>= tz;
                l += 1;
            } else if kk <= 7 {
                chain[l] = kk as i8;
                return l + 1;
            } else {
                // Integer is odd, look at 4 LSB.
                let r = kk % 16;
                if r < 8 {
                    // Encode as 2k+r
                    chain[l] = r as i8;
                    l += 1;
                    kk = (kk - r) / 2;
                } else {
                    // Encode as 2k-r
                    let rop = 16 - r;
                    chain[l] = -(rop as i8);
                    l += 1;
                    kk = (kk + rop) / 2;
                }
            }
        }
    }

    pub fn scalar1024_chainmul(&self, k: &U1024, p: &Point) -> Point {
        // Use blocks of 6 bits in the double-add-sub chains.
        // On average, 8 bits will be consumed. The expected average cost is:
        // - 12 MUL for initial doubling, conversion to extended
        // - 1024 DBL (7 multiplications each)
        // - 31 ADDEXT to compute 3P...63P (8 multiplications each)
        // - ~128 point additions (8 multiplications each)
        // so about 8.25 multiplications per exponent bit.
        if k.is_zero() {
            let zn = &self.zn;
            return Point(zn.zero(), zn.one(), zn.one());
        }
        // Use mixed projective/extended coordinates.
        // This is the same code as `scalar64_chainmul`.
        let pext = self.to_extended(p);
        let p2 = self.dblext(p);
        // Store p, 3p ... 63p
        let mut gaps = Vec::with_capacity(32);
        gaps.push(pext);
        for i in 1..32 {
            let pi = self.addext(&gaps[i - 1], &p2);
            gaps.push(pi);
        }
        // Construct chain
        let mut c = [0_i8; 384];
        let l = Self::make_addition_chain_long(&mut c, k);
        // Get initial element (chain[l-1] = 1 or 3 or ... 63)
        let mut q = gaps[c[l - 1] as usize / 2].to_proj();
        for idx in 1..l {
            let op = c[l - 1 - idx];
            if op % 2 == 0 {
                for _ in 0..op / 2 {
                    q = self.double(&q);
                }
            } else {
                let q2 = self.dblext(&q);
                if op > 0 {
                    q = self.addextproj(&q2, &gaps[op as usize / 2]);
                } else {
                    q = self.subextproj(&q2, &gaps[(-op) as usize / 2]);
                }
            }
        }
        q
    }

    fn make_addition_chain_long(chain: &mut [i8; 384], n: &U1024) -> usize {
        // We intentionally assert that Uint is 1024 bits.
        // The add/sub will use odd integers from 1 to 63 (6 bits)
        // After each add/sub we expect to perform >= 6 doubles
        // The chain length cannot be more than 340
        // (there are at most 1024/6 blocks)
        //
        // This function does not implement the special edge cases
        // that save 1/2 adds in `make_addition_chain`
        //
        // Encoding:
        // 2k => P -> 2^k P (k <= 63)
        // +k => P -> 2P + kG (k is odd)
        // -k => P -> 2P - kG (k is odd)
        let nd: &[u64; 16] = n.digits();
        // Start from LSB and work with 2 words at a time.
        let mut exp = nd[0] as u128;
        let mut nextword = 1;
        let mut idx = 0;
        // How many bits were processed
        let mut bits = 0;
        // How many bits are stored in exp.
        let mut curbits = if n.bits() >= 64 {
            64
        } else {
            u128::BITS - u128::leading_zeros(exp)
        };
        let nbits = n.bits();
        let lastword = (nbits as usize - 1) / 64;
        while bits < nbits || exp > 0 {
            if curbits <= 32 && nextword <= lastword {
                exp += (nd[nextword] as u128) << curbits;
                nextword += 1;
                curbits += 64;
            }
            if exp & 1 == 0 {
                // We cannot shift right by 128 and we cannot store
                // large numbers in the chain, so limit tz to 60.
                let tz = min(60, min(exp.trailing_zeros(), curbits));
                exp >>= tz;
                bits += tz;
                curbits -= tz;
                chain[idx] = 2 * tz as i8;
                idx += 1;
            } else {
                let low = exp & 127;
                debug_assert!(low % 2 == 1);
                if low < 64 {
                    chain[idx] = low as i8;
                    idx += 1;
                    exp -= low;
                    if exp == 0 && nbits - bits <= 6 {
                        // Finished!
                        break;
                    }
                } else {
                    chain[idx] = -((128 - low) as i8);
                    idx += 1;
                    // Note: exp may become larger than 1 << curbits.
                    exp += 128 - low;
                }
                // Always combine additions with doubling.
                // This means we consume 1 bit after emitting this opcode.
                exp >>= 1;
                bits += 1;
                curbits -= 1;
            }
        }
        idx
    }

    #[cfg(test)]
    fn scalar_mul(&self, k: Uint, p: &Point) -> Point {
        let zn = &self.zn;
        let mut res = Point(zn.zero(), zn.one(), zn.one());
        let mut sq: Point = p.clone();
        let mut k = k;
        while k > Uint::ZERO {
            if k.bit(0) {
                res = self.add(&res, &sq);
            }
            sq = self.double(&sq);
            k >>= 1;
        }
        res
    }

    /// A projective plane point [x:y:z] defines an extended point by
    /// the Segre embedding of ([x:z], [y:z])
    fn to_extended(&self, p: &Point) -> ExtPoint {
        let zn = &self.zn;
        ExtPoint(
            zn.mul(&p.0, &p.2),
            zn.mul(&p.1, &p.2),
            zn.mul(&p.2, &p.2),
            zn.mul(&p.0, &p.1),
        )
    }

    fn is_valid(&self, p: &Point) -> bool {
        // (±x²+y²)z² = z^4 + dx²y²
        let zn = &self.zn;
        let x2 = zn.mul(p.0, p.0);
        let y2 = zn.mul(p.1, p.1);
        let z2 = zn.mul(p.2, p.2);
        let lhs = if self.twisted {
            zn.mul(zn.sub(y2, x2), z2)
        } else {
            zn.mul(zn.add(x2, y2), z2)
        };
        let rhs = zn.add(zn.mul(z2, z2), zn.mul(self.d, zn.mul(x2, y2)));
        lhs == rhs
    }

    #[cfg(test)]
    fn is_validext(&self, p: &ExtPoint) -> bool {
        // ax²+ y² = z² + dt²
        let zn = &self.zn;
        let x2 = zn.mul(p.0, p.0);
        let y2 = zn.mul(p.1, p.1);
        let z2 = zn.mul(p.2, p.2);
        let t2 = zn.mul(p.3, p.3);
        let lhs = if self.twisted {
            zn.sub(&y2, &x2)
        } else {
            zn.add(&y2, &x2)
        };
        let rhs = zn.add(&z2, &zn.mul(&self.d, &t2));
        lhs == rhs
    }

    #[cfg(test)]
    fn is_2_torsion(&self, p: &Point) -> Option<Uint> {
        let d = self.zn.gcd(&p.0);
        if d == Uint::ONE {
            None
        } else {
            Some(d)
        }
    }

    #[cfg(test)]
    fn equal(&self, p: &Point, q: &Point) -> bool {
        projective_equal(&self.zn, p, q)
    }

    pub(crate) fn is_twisted128(&self) -> bool {
        self.twisted && self.zn.words() == 2
    }
}

// Test equality of points in the projective plane.
#[cfg(test)]
fn projective_equal(zn: &ZmodN, p: &Point, q: &Point) -> bool {
    zn.mul(p.0, q.1) == zn.mul(p.1, q.0)
        && zn.mul(p.1, q.2) == zn.mul(p.2, q.1)
        && zn.mul(p.2, q.0) == zn.mul(p.0, q.2)
}

// The modular curve for Suyama-11 family equipped with a non-6-torsion point.
// This is a double cover of the rational parameter space (parameter σ)
// corresponding to the 2 choices of x-coordinates for the standard choice of
// the y-coordinate.
// The pointed curves can be parameterized by an elliptic curve:
// v^2 = u^3 - u^2 - 120 u + 432
// where σ, y0 are rational functions of u and x0 = v f(σ)
//
// The 2-torsion points are (-12,0) (4,0) and (9,0)
// An infinite order point is G=(12,24)
//
// For k > 1, kG+T where T is torsion is a valid parameter.
// Points P and P+(4,0) produce identical parameters.
// Point (2 : -14) corresponds to σ=11
// Point (44, -280) corresponds to σ=-5/11
//
// Set [u:v] = [3x+z : 3y : 3z] to get a short Weierstrass model:
// y^2 = x^3 - 361/3 x + 10582/27
// Set A = -361/3, B = 10582/27
//
// We will compute points in projective coordinates and convert back
// to σ and distinguished point (x0, y0).
#[doc(hidden)]
pub struct Suyama11<'a> {
    zn: &'a ZmodN,
    a: MInt,
    b: MInt,
    gx: MInt,
    gy: MInt,
}

impl<'a> Suyama11<'a> {
    #[doc(hidden)]
    pub fn new(zn: &'a ZmodN) -> Result<Self, UnexpectedFactor> {
        let n3 = zn.n / 3;
        let one_third = match zn.n % 3_u64 {
            // n=3k+1
            1 => zn.from_int(zn.n - n3),
            // n=3k+2
            2 => zn.from_int(n3 + Uint::ONE),
            _ => return Err(UnexpectedFactor(3_u64)),
        };
        debug_assert!(zn.mul(zn.from_int(3_u64.into()), one_third) == zn.one());
        let a = zn.mul(
            zn.sub(zn.zero(), zn.from_int(Uint::from_digit(361_u64))),
            one_third,
        );
        let b = zn.mul(
            zn.from_int(10582_u64.into()),
            zn.mul(one_third, zn.mul(one_third, one_third)),
        );
        // Generator is (12 - 1/3, 24)
        let gx = zn.sub(zn.from_int(Uint::from_digit(12)), one_third);
        let gy = zn.from_int(Uint::from_digit(24));
        let s = Suyama11 { zn, a, b, gx, gy };
        assert!(s.is_valid(&Point(gx, gy, zn.one())));
        Ok(s)
    }

    // Select parameter defined by (seed + 2)G
    // where G is the rational generator of the curve.
    #[doc(hidden)]
    pub fn element(&self, seed: u32) -> Result<Point, UnexpectedLargeFactor> {
        assert!(seed > 1);
        let zn = &self.zn;
        let bitlen = u32::BITS - u32::leading_zeros(seed);
        let mut bit = bitlen - 1;
        assert!(bit > 0);
        // We assume that the modulus is not divisible by 2 or 3,
        // so the initial parameter point has invertible coordinates.
        let g: Point = Point(self.gx, self.gy, zn.one());
        let mut res = g.clone();
        loop {
            // If the denominator z(res2) is zero, is means that
            // y(res) or z(res) must have a common factor with n.
            // Most probably each of them had a different factor.
            let res2 = self.double(&res);
            if res2.2 == zn.zero() {
                // We know that z(res) was not zero:
                let n = &zn.n;
                let d = Integer::gcd(n, &Uint::from(res.2));
                if d != Uint::ONE && &d != n {
                    return Err(UnexpectedLargeFactor(d));
                }
                // The only possibility is that y(res) was zero.
                let d = Integer::gcd(n, &Uint::from(res.1));
                if d != Uint::ONE {
                    return Err(UnexpectedLargeFactor(d));
                }
            }
            res = res2;
            bit -= 1;
            if (seed >> bit) & 1 == 1 {
                res = self.add_g(&res);
            }
            if bit == 0 {
                break;
            }
        }
        Ok(res)
    }

    // Addition of a projective point and affine point G.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-projective.html#addition-madd-1998-cmo
    fn add_g(&self, pt: &Point) -> Point {
        let zn = self.zn;
        // secant slope = u/v = (y/z - gy) / (x/z - gx)
        let u = zn.sub(&zn.mul(&self.gy, &pt.2), &pt.1);
        let v = zn.sub(&zn.mul(&self.gx, &pt.2), &pt.0);
        // Ordinary projectivized formulas.
        // Multiply by v^3 z to clear denominators.
        let u2 = zn.mul(&u, &u);
        let v2 = zn.mul(&v, &v);
        let v3 = zn.mul(&v, &v2);
        let r = zn.mul(&v2, &pt.0);
        let aa = zn.sub(zn.sub(&zn.mul(&u2, &pt.2), &v3), zn.add(r, r));
        // Y = u(R-A) - v^3 Y1
        let y = zn.sub(&zn.mul(u, zn.sub(&r, &aa)), &zn.mul(&v3, &pt.1));
        Point(zn.mul(&v, &aa), y, zn.mul(&v3, &pt.2))
    }

    // Doubling formula for a projective point.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-projective.html#doubling-dbl-2007-bl
    fn double(&self, pt: &Point) -> Point {
        let zn = &self.zn;
        let xx = zn.mul(&pt.0, &pt.0);
        let zz = zn.mul(&pt.2, &pt.2);
        let yz = zn.mul(&pt.1, &pt.2);
        let xx_2 = zn.add(&xx, &xx);
        // w = a z^2 + 3 x^2
        let w = zn.add(&zn.mul(&self.a, &zz), &zn.add(&xx, &xx_2));
        let s = zn.add(&yz, &yz); // 2yz
        let s2 = zn.mul(&s, &s);
        let r = zn.mul(&pt.1, &s);
        let rr = zn.mul(&r, &r);
        // b = (x+r)^2 - x^2 - r^2 = 2xr
        let b_half = zn.mul(&pt.0, &r);
        let b = zn.add(&b_half, &b_half);
        // h = w^2 - 2B
        let h = zn.sub(&zn.mul(w, w), &zn.add(&b, &b));
        let x3 = zn.mul(&h, &s);
        // Y = w(B-h) - 2RR
        let y3 = zn.sub(&zn.mul(&w, &zn.sub(&b, &h)), &zn.add(&rr, &rr));
        let z3 = zn.mul(&s, &s2);
        Point(x3, y3, z3)
    }

    #[doc(hidden)]
    pub fn params(&self, pt: &Point) -> Result<(MInt, MInt), UnexpectedLargeFactor> {
        let zn = self.zn;
        // If [u:v:1] = [3x+z : 3y : 3z] the parameters
        // are σ = 24/u - 1 and r = 48v / u^2
        // σ = 72z/(3x + z) - 1
        // r = 48 * 9yz / (3x+z)^2
        let x3_z = zn.add(zn.add(pt.2, pt.0), zn.add(pt.0, pt.0));
        let x3_z_inv2 = match zn.inv(zn.mul(x3_z, x3_z)) {
            Some(inv) => inv,
            None => return Err(UnexpectedLargeFactor::new(zn, &x3_z)),
        };

        let sigma = zn.sub(
            zn.mul(
                zn.mul(zn.from_int(Uint::from_digit(72)), pt.2),
                zn.mul(x3_z, x3_z_inv2),
            ),
            zn.one(),
        );

        let r = zn.mul(
            zn.mul(pt.1, pt.2),
            zn.mul(zn.from_int(Uint::from_digit(48 * 9)), x3_z_inv2),
        );
        Ok((sigma, r))
    }

    /// Returns a projective point generating the twisted Edwards curve
    /// represented by `pt` in the modular curve.
    pub fn params_point(&self, pt: &Point) -> Result<Point, UnexpectedLargeFactor> {
        // α = σ^2 - 5
        // β = 4σ
        // x = (2rσ) / (σ - 1)(σ + 5)(σ**2 + 5)
        // y = (α**3 - β**3) / (α**3 + β**3)
        let zn = self.zn;
        let (s, r) = self.params(pt)?;
        let five = zn.from_int(5_u64.into());
        let a = zn.sub(zn.mul(&s, &s), five);
        let β = zn.mul(&s, &zn.from_int(4_u64.into()));
        let a3 = zn.mul(&a, &zn.mul(&a, &a));
        let β3 = zn.mul(&β, &zn.mul(&β, &β));
        let xn = zn.mul(&r, &s);
        let xn = zn.add(&xn, &xn);
        let xd = zn.mul(
            zn.mul(zn.sub(s, zn.one()), zn.add(s, five)),
            zn.add(zn.mul(&s, &s), five),
        );
        // Clear denominators (xn/xd, yn/yd) = [xn*yd:yn*xd:xd*yd]
        let yn = zn.sub(&a3, &β3);
        let yd = zn.add(&a3, &β3);
        Ok(Point(zn.mul(&xn, &yd), zn.mul(&yn, &xd), zn.mul(&xd, &yd)))
    }

    fn is_valid(&self, pt: &Point) -> bool {
        // Check whether y^2 z = x^3 + A x z^2 + B z^3
        let zn = self.zn;
        let y2z = zn.mul(&pt.2, &zn.mul(&pt.1, &pt.1));
        let zz = zn.mul(&pt.2, &pt.2);
        let x3 = zn.mul(&pt.0, &zn.mul(&pt.0, &pt.0));
        let ax_bz = zn.add(&zn.mul(&self.a, &pt.0), &zn.mul(&self.b, &pt.2));
        y2z == zn.add(&x3, &zn.mul(&ax_bz, &zz))
    }
}

#[cfg(test)]
use std::str::FromStr;

#[cfg(test)]
const MODULUS256: &'static str =
    "107910248100432407082438802565921895527548119627537727229429245116458288637047";

#[test]
fn test_curve() {
    use std::str::FromStr;
    let n = Uint::from_str("2953951639731214343967989360202131868064542471002037986749").unwrap();
    let c = Curve::from_point(ZmodN::new(n), 2, 3).unwrap();
    eprintln!("d={}", c.zn.to_int(c.d));
    let g = c.gen();
    assert!(c.is_valid(&g));
    assert!(c.is_valid(&c.add(&g, &g)));
    assert!(c.is_valid(&c.double(&g)));

    // Edwards curve(d) is equivalent to Y² = X³ + (1 − 2c)X² + c^2 X where c = (1-d)/4
    // This curve has orders 59528557881166853791031641960 and 49622429047046610830438562488
    // modulo the factors of n (49622429047046386146923837183 * 59528557881167220232630894403)
    let ord1 = Uint::from_str("49622429047046610830438562488").unwrap();
    let ord2 = Uint::from_str("59528557881166853791031641960").unwrap();
    let g1 = c.scalar_mul(ord1, &g);
    assert!(c.is_2_torsion(&g1).is_some());
    eprintln!("factor {}", c.is_2_torsion(&g1).unwrap());
    assert_eq!(
        c.is_2_torsion(&g1),
        Uint::from_str("49622429047046386146923837183").ok()
    );
    let g2 = c.scalar_mul(ord2, &g);
    assert!(c.is_2_torsion(&g2).is_some());
    eprintln!("factor {}", c.is_2_torsion(&g2).unwrap());
    assert_eq!(
        c.is_2_torsion(&g2),
        Uint::from_str("59528557881167220232630894403").ok()
    );

    // Test extended coordinates.
    let g1 = c.scalar64_chainmul(123_456_789, &g);
    let g2 = c.scalar64_chainmul(987_654_321, &g);
    let g1ext = c.to_extended(&g1);
    let g2ext = c.to_extended(&g2);
    assert!(c.is_validext(&g1ext));
    assert!(c.is_validext(&g2ext));
    let g12 = c.add(&g1, &g2);
    let g12ext = c.addext(&g1ext, &g2ext);
    assert!(c.is_validext(&g12ext));
    assert!(c.equal(&g12, &g12ext.to_proj()));

    // Doubling in extended coordinates
    assert!(c.equal(&c.double(&g1), &c.dblext(&g1).to_proj()));
    assert!(c.equal(&c.double(&g2), &c.dblext(&g2).to_proj()));
}

#[test]
fn test_twisted_curve() {
    let p = Uint::from(602768606663711_u64);
    let q = Uint::from(957629686686973_u64);
    let n = p * q;
    let zn = ZmodN::new(n);
    // The σ=11 twisted Edwards curve.
    // Its order is:
    // mod p: 602768647071432 = 2^3 * 3^2 * 17 * 251 * 4679 * 419317
    // mod q: 957629727109848 = 2^3 * 3 * 13 * 359 * 8549654731
    let gx = Curve::fraction_modn(&zn, -11, 60).unwrap();
    let gy = Curve::fraction_modn(&zn, 11529, 12860).unwrap();
    let g = Point(gx, gy, zn.one());
    let c = Curve::twisted_from_point(zn.clone(), g).unwrap();
    let g = c.gen();
    assert!(c.is_valid(&g));

    let g1 = c.scalar64_chainmul(602768647071432, &g);
    assert!(c.is_valid(&g1));
    let g2 = c.scalar64_chainmul(957629727109848, &g1);
    assert!(c.is_valid(&g2));

    assert!(c.is_2_torsion(&g1) == Some(p));
    assert!(&g2.0 == &zn.zero());

    // Test extended coordinates.
    let g1 = c.scalar64_chainmul(123_456_789, &g);
    let g2 = c.scalar64_chainmul(987_654_321, &g);
    let g1ext = c.to_extended(&g1);
    let g2ext = c.to_extended(&g2);
    assert!(c.is_validext(&g1ext));
    assert!(c.is_validext(&g2ext));
    let g12 = c.add(&g1, &g2);
    let g12ext = c.addext(&g1ext, &g2ext);
    assert!(c.is_validext(&g12ext));
    assert!(c.equal(&g12, &g12ext.to_proj()));
    // Doubling in extended coordinates
    assert!(c.equal(&c.double(&g1), &c.dblext(&g1).to_proj()));
    assert!(c.equal(&c.double(&g2), &c.dblext(&g2).to_proj()));
}

#[test]
fn test_ecm_curve() {
    let p = Uint::from(602768606663711_u64);
    let q = Uint::from(957629686686973_u64);
    let n = p * q;
    let zn = ZmodN::new(n);
    // This curve has smooth order for prime 602768606663711
    // order: 2^2 * 7 * 19 * 29 * 347 * 503 * 223843
    let c = Curve::from_point(zn.clone(), 2, 10).unwrap();
    let sb = SmoothBase::new(1000, true);
    let res = ecm_curve(&sb, &zn, &c, 500e3, Verbosity::Silent);
    eprintln!("{:?}", res);
    assert_eq!(res, Some((p, q)));
}

#[test]
fn test_ecm_curve2() {
    use std::str::FromStr;
    let p = Uint::from_str("1174273970803390465747303").unwrap();
    let q = Uint::from_str("607700066377545220515437").unwrap();
    let n = p * q;
    let zn = ZmodN::new(n);
    // This curve has smooth order for prime 1174273970803390465747303
    // Order has largest prime factors 11329 and 802979
    let c = Curve::from_point(zn.clone(), 2, 132).unwrap();
    let sb = SmoothBase::new(15000, true);
    let res = ecm_curve(&sb, &zn, &c, 1.37e6, Verbosity::Silent);
    eprintln!("{:?}", res);
    assert_eq!(res, Some((p, q)));
}

#[test]
fn test_ecm_curve3() {
    // Numbers selected to make the Suyama-11 family difficult
    // (the image of rational parameters modulo n is very small).

    // The generator of Suyama11 has order 10 modulo 3011 * 3259
    let n = Uint::from_digit(3011 * 3259);
    let mut prefs = Preferences::default();
    prefs.verbosity = Verbosity::Debug;
    let res = ecm(n, 10, 3, 20., &prefs, None);
    assert!(res.is_some());
    assert!(matches!(res.unwrap().0.digits()[0], 3011 | 3259));

    // A divisor of the numerator of 8G.
    let n = Uint::from_digit(8596409 * 2621197441);
    let res = ecm(n, 10, 300, 2000., &prefs, None);
    assert!(res.is_some());
    let (p, q) = res.unwrap();
    assert!(p * q == n);

    // A product of 2 large prime factors of y(16G)
    // 187517650311848773700321 * 26717264479748082280693283115460047361
    // This causes a large number of failures.
    // Test is too long for unit tests.
    if false {
        let n = Uint::from_str("5009958658002579145918829006654645409818655474751833880902881")
            .unwrap();
        let res = ecm(n, 100, 120_000, 20e6, &prefs, None);
        assert!(res.is_some());
        let (p, q) = res.unwrap();
        assert!(p * q == n);
    }
}

#[test]
fn test_addition_chain() {
    fn eval_chain(c: &[i8]) -> u64 {
        let mut k = c[c.len() - 1] as u64;
        for idx in 1..c.len() {
            let op = c[c.len() - 1 - idx];
            if op % 2 == 0 {
                k <<= (op / 2) as u32;
            } else {
                k = ((2 * k as i64) + (op as i64)) as u64;
            }
        }
        k
    }

    for k in 1..1000_u64 {
        let mut c = [0i8; 32];
        let l = Curve::make_addition_chain(&mut c, k);
        assert_eq!(k, eval_chain(&c[..l]), "chain={:?}", &c[..l]);
    }
    {
        let k = 602768647071432_u64;
        let mut c = [0i8; 32];
        let l = Curve::make_addition_chain(&mut c, k);
        assert_eq!(k, eval_chain(&c[..l]), "chain={:?}", &c[..l]);
    }
    let mut adds = 0;
    let mut maxsize = 0;
    for i in 1..=1000_u64 {
        let mut c = [0i8; 32];
        let k = i.wrapping_mul(1_234_567_123_456_789);
        let l = Curve::make_addition_chain(&mut c, k);
        assert_eq!(k, eval_chain(&c[..l]), "chain={:?}", &c[..l]);
        adds += 3;
        for &op in &c[..l - 1] {
            if op & 1 == 1 {
                adds += 1;
            }
        }
        maxsize = max(maxsize, l);
    }
    eprintln!(
        "average additions {:.2} for 64-bit integers",
        adds as f64 / 1000.0
    );
    eprintln!("max chain size {maxsize}");

    let n = Uint::from_str(MODULUS256).unwrap();
    let zn = ZmodN::new(n);
    let c = Curve::from_point(zn, 2, 132).unwrap();
    let k: u64 = 1511 * 1523 * 1531 * 1543 * 1549 * 1553;
    let p1 = c.scalar64_mul_dbladd(k, &c.gen());
    let p2 = c.scalar64_chainmul(k, &c.gen());
    assert!(c.equal(&p1, &p2));
    for k in 0..2000 {
        let p1 = c.scalar64_mul_dbladd(k, &c.gen());
        let p2 = c.scalar64_chainmul(k, &c.gen());
        assert!(c.equal(&p1, &p2), "failure for k={k}");
    }
}

#[test]
fn test_addition_chain_long() {
    use bnum::cast::CastFrom;
    use bnum::types::U2048;
    use rand::Rng;

    fn eval_chain(c: &[i8]) -> U1024 {
        let mut k = U2048::from_digit(c[c.len() - 1] as u64);
        for idx in 1..c.len() {
            let op = c[c.len() - 1 - idx];
            if op % 2 == 0 {
                k <<= (op / 2) as u32;
            } else if op > 0 {
                k <<= 1;
                k += U2048::from_digit(op as u64);
            } else {
                k <<= 1;
                k -= U2048::from_digit((-op) as u64);
            }
        }
        U1024::cast_from(k)
    }

    // Some sparse numbers
    for i in 900..1020 {
        let j = i - 400;
        let k = U1024::power_of_two(i) | U1024::power_of_two(j);
        let mut c = [0i8; 384];
        let l = Curve::make_addition_chain_long(&mut c, &k);
        assert_eq!(k, eval_chain(&c[..l]), "chain={:?}", &c[..l]);
        // Test negative steps
        let j1 = i - 300;
        let j2 = i / 2;
        let k = U1024::power_of_two(i) + U1024::power_of_two(j1) - U1024::power_of_two(j2);
        let l = Curve::make_addition_chain_long(&mut c, &k);
        assert_eq!(k, eval_chain(&c[..l]), "chain={:?}", &c[..l]);
    }

    // Random numbers: assume that 10000 is enough to express
    // all 8-bit patterns.
    let mut adds = 0;
    let mut maxsize = 0;
    for _ in 0..10000 {
        let mut rng = rand::thread_rng();
        let mut digits = [0; 16];
        let mut c = [0i8; 384];
        rng.fill(&mut digits);
        let k = U1024::from_digits(digits);
        let l = Curve::make_addition_chain_long(&mut c, &k);
        assert_eq!(k, eval_chain(&c[..l]), "chain={:?}", &c[..l]);
        adds += c[..l - 1].iter().filter(|&x| x & 1 == 1).count();
        maxsize = max(maxsize, l);
    }
    eprintln!(
        "average additions {:.2} for 1024-bit integers",
        adds as f64 / 10000.0
    );
    eprintln!("max chain size {maxsize}");

    let n = Uint::from_str(MODULUS256).unwrap();
    let zn = ZmodN::new(n);
    let c = Curve::from_point(zn, 2, 132).unwrap();
    let k: u64 = 1511 * 1523 * 1531 * 1543 * 1549 * 1553;
    let p1 = c.scalar64_mul_dbladd(k, &c.gen());
    let p2 = c.scalar1024_chainmul(&(k.into()), &c.gen());
    assert!(c.equal(&p1, &p2), "failure for k={k}");
    for k in 0..100 {
        let k = k * 12345678_123456789;
        let k2 = Uint::from(k) * Uint::from(k);
        let p1 = c.scalar64_mul_dbladd(k, &c.scalar64_mul_dbladd(k, &c.gen()));
        let p2 = c.scalar1024_chainmul(&k2, &c.gen());
        assert!(c.equal(&p1, &p2), "failure for k={k}^2");
    }
}

#[test]
fn test_suyama11() {
    let p = Uint::from_str("1174273970803390465747303").unwrap();
    let zn = ZmodN::new(p);
    let s = Suyama11::new(&zn).unwrap();

    // Test generation of points.
    let g: Point = Point(s.gx, s.gy, zn.one());
    let mut gk = g;
    for k in 2..600 {
        gk = s.add_g(&gk);
        assert!(projective_equal(&zn, &gk, &s.element(k as u32).unwrap()));
    }

    // σ=11/13 for 2G
    let sigma = s.params(&s.element(2).unwrap()).unwrap().0;
    assert_eq!(sigma, Curve::fraction_modn(&zn, 11, 13).unwrap());
    // σ=-239/241 for 3G
    let sigma = s.params(&s.element(3).unwrap()).unwrap().0;
    assert_eq!(sigma, Curve::fraction_modn(&zn, -239, 241).unwrap());

    // Unexpected factors:
    // G has order 14 modulo 311 and order 10 modulo 3259.
    let zn = ZmodN::new(Uint::from_digit(311 * 3259));
    let s = Suyama11::new(&zn).unwrap();
    // 14G is at infinity modulo 311 so 15G is undefined.
    let Err(err) = s.element(31) else {
        panic!("expected error")
    };
    assert!(err.0 == Uint::from_digit(311) || err.0 == Uint::from_digit(3259));
}
